# Frontend System Design: Financial Dashboard (Trading View)

## ğŸ“‹ Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ

Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ° ÑƒÑ€Ğ¾Ğº Ğ¿Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ¼Ñƒ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ñƒ Financial Dashboard â€” Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° Ñ„Ğ¸Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ‹Ñ… Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¾Ğ² Ñ real-time Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸, drag-and-drop Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ¼ Ğ¸ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¼ĞµĞ¶Ğ´Ñƒ charts.

**Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Trading View:**
- ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ñ„Ğ¸Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ‹Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¸ Ğ½Ğ° ÑĞºÑ€Ğ°Ğ½Ğµ
- Resizable layouts (6-column, 8Ã—8 grid, etc.)
- Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ interval Ğ¸ symbol
- Real-time financial data
- Multi-monitor support

**Ğ¢Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸:** Trading companies, Bloomberg, E*TRADE, Robinhood

---

## ğŸ“ ĞŸĞ»Ğ°Ğ½ System Design

1. âœ… **Requirements & Mockup**
2. âœ… **Layout Design (CSS Grid + Sandwich)** â­
3. âœ… **Data & Property Model**
4. âœ… **Data Storage (IndexedDB + Bucketing)** â­
5. âœ… **Data API (WebTransport vs WebSockets)**
6. âœ… **Multi-Window Support**

---

## 1. ğŸ“Œ Requirements

### Product Requirements:

**1. Multiple Resizable Charts**
```
User configures layout
Grid-based system
```

**2. Unified Data Interface**
```
Different APIs (legacy + new)
â†’ Same data format
â†’ Single interface
```

**3. Extensible Chart Types**
```
Each chart type:
- Different data model
- Transform generic data â†’ chart-specific
```

**4. Synchronization**
```
Sync by:
- Asset ID (Apple â†’ Ğ²ÑĞµ charts Apple)
- Timeframe (1h â†’ Ğ²ÑĞµ charts 1h)
```

---

### Non-Product Requirements:

**1. Network Performance â­**
```
ĞĞ³Ñ€Ğ¾Ğ¼Ğ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
Browser cache optimization
```

**2. Rendering Stability**
```
Change timeframe: 1d â†’ 1h
â†’ Downscale existing data
â†’ Show partial chart (Ğ½Ğµ Ğ¶Ğ´Ğ°Ñ‚ÑŒ API)
```

**3. Legacy API Support**
```
Unified interface
Multiple endpoints
Same response format
```

---

## 2. ğŸ¨ Layout Design â€” ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ•! â­

### Mockup:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Chart 1]  â”‚  [Chart 2]  â”‚  [Chart 3] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [Chart 4]              â”‚  [Chart 5]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [Chart 6]  â”‚  [Chart 7]  â”‚  [Chart 8] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Resizable, drag-and-drop
```

---

### CSS Grid System

**Requirements:**
```
âœ… User adjusts grid (8Ã—8, 6Ã—12, etc.)
âœ… Modern browsers only (trading desks)
â†’ CSS Grid support guaranteed
```

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ CSS Grid:**
```
âœ… Natural grid (vs Flexbox)
âœ… Native CSS standard
âœ… Perfect Ğ´Ğ»Ñ Ğ½Ğ°ÑˆĞµĞ³Ğ¾ use case
```

---

### Sandwich Design â€” 3 Layers â­

**ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ:**
```
Layer 1: Grid Container (CSS Grid)
Layer 2: Cell Grid (drag-and-drop handlers)
Layer 3: Chart Containers (actual charts)
```

**Visualisation:**

```
Step 1: Create Grid Container
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚  â† Columns
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚   â”‚   â”‚  â† Rows
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

CSS:
.container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(3, 1fr);
}
```

---

**Step 2: Create Cell Grid (Layer 2)**

```
Each cell = droppable container

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚â–“â–“â–“â”‚   â”‚   â”‚   â”‚  â† data-row="0" data-col="0"
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚   â”‚   â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Each cell:
<div 
  data-row="0" 
  data-col="0"
  class="drop-cell"
>
</div>
```

---

**Step 3: Place Chart (Layer 3)**

```
Chart dropped Ğ½Ğ° row=0, col=0
Span: 2 columns Ã— 2 rows

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ Chart 1 â”‚   â”‚   â”‚
â”‚         â”‚   â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

CSS:
.chart {
  grid-column: 1 / 3;  /* span 2 cols */
  grid-row: 1 / 3;     /* span 2 rows */
}
```

---

### Event Delegation â­

**Problem:**
```
8Ã—8 grid = 64 cells
64 event handlers = Memory inefficient
```

**Solution: Event Bubbling**

```
Grid Container (root)
  â†‘ Events bubble up
Cell Ã— 64 (emit events)

Register 1 handler Ğ½Ğ° root
â†’ Detect target cell via event.target
â†’ Get data attributes
```

**Implementation:**

```typescript
gridContainer.addEventListener('drop', (e) => {
  const target = e.target.closest('[data-row][data-col]');
  
  const row = target.dataset.row;
  const col = target.dataset.col;
  
  // Place chart
  placeChart(row, col);
});
```

**Benefits:**
```
âœ… 1 handler Ğ²Ğ¼ĞµÑÑ‚Ğ¾ 64
âœ… Memory efficient
âœ… Performance optimized
```

---

### CSS Grid Overlapping

**ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ Ñ„Ğ¸Ñ‡Ğ°:**
```
CSS Grid allows multiple items in same cell
â†’ "Sandwich" multiple layers
```

**Layers:**
```
Z-index 1: Grid container
Z-index 2: Cell grid (droppable)
Z-index 3: Charts (visible)
```

---

## 3. ğŸ“Š Data & Property Model

### Component Hierarchy:

```
Draggable (generic drag-and-drop)
    â†“
Dashboard Component (data fetching)
    â†“
Chart Element (data transformation)
```

---

### Interfaces:

```typescript
// 1. Chart Element Interface
interface IChartElement<T> {
  // Transform generic data â†’ chart-specific
  transformer(source: TData): T;
}

// All charts implement this:
class DataTable implements IChartElement<TableData> { }
class PieChart implements IChartElement<PieData> { }
class LineChart implements IChartElement<LineData> { }
```

---

### TData (Generic Financial Data):

```typescript
interface TData {
  asset: string;        // "AAPL"
  start: number;        // timestamp
  end: number;          // timestamp
  interval: Interval;   // "1h", "5m", "1d"
  points: Point[];
}

interface Point {
  open: number;   // Opening price
  close: number;  // Closing price
}

type Interval = "1m" | "5m" | "1h" | "1d" | "1w";
```

---

### Dashboard Component:

```typescript
interface TDashboardComponent {
  // State
  range: { start: number; end: number };
  asset: string;
  interval: Interval;
  
  // Chart type
  component: TChartUnion;  // "pie" | "line" | "table"
  
  // Custom render (optional)
  render?(source: TData): Component;
}
```

**ĞšĞ»ÑÑ‡ĞµĞ²Ğ¾Ğµ:**
```
Dashboard Component:
- Controls API requests
- Manages state (range, interval, asset)
- Passes data to charts
```

---

## 4. ğŸ—„ï¸ Data Storage â€” ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ! â­

### Problem: Large Dataset

**Scenario:**
```
1 second = 1 point
1 day = 86,400 points
1 year = 31,536,000 points

Storing in RAM = âŒ Not scalable
```

---

### Solution: IndexedDB + Bucketing

**IndexedDB:**
```
Browser local database
30% of hard drive available
~2GB per domain
Perfect Ğ´Ğ»Ñ large datasets
```

---

### Flattened Structure:

```typescript
interface ApplicationState {
  [assetId: string]: {
    [bucketKey: string]: Point[];
  };
}
```

---

### Bucketing Strategy â­

**Problem: O(n) Scan**

```
Naive approach:
1 point = 1 entry

Fetch 60 minutes of 1-second data:
â†’ Scan 3,600 points
â†’ O(3600) = Slow!
```

---

**Solution: 5-minute Buckets**

```
Bucket 0: 00:00 - 05:00 (300 points)
Bucket 1: 05:00 - 10:00 (300 points)
Bucket 2: 10:00 - 15:00 (300 points)
...
Bucket 11: 55:00 - 60:00 (300 points)

Fetch 60 minutes:
â†’ Scan 12 buckets
â†’ O(12) = Fast! âœ…
```

---

### Compound Key (3 parts):

```typescript
interface BucketKey {
  assetId: string;     // "AAPL"
  bucketId: number;    // 0, 1, 2, ...
  timeframe: string;   // "5m", "1h", "1d"
}

// Example keys:
"AAPL-0-5m"   â†’ Bucket 0, 5-minute timeframe
"AAPL-1-5m"   â†’ Bucket 1, 5-minute timeframe
"AAPL-0-1h"   â†’ Bucket 0, 1-hour timeframe
```

---

### Multiple Timeframes:

```
Same data, different buckets:

5-minute buckets:  288 buckets/day
1-hour buckets:    24 buckets/day
1-day buckets:     365 buckets/year

Storage overhead: âœ… Acceptable
â†’ On disk, not RAM
â†’ Fast access
```

---

### Bucket ID Calculation:

```typescript
function getBucketId(
  timestamp: number,
  bucketSize: number
): number {
  return Math.floor(timestamp / bucketSize);
}

// Examples:
timestamp = 300001 ms  (5:00:01)
bucketSize = 300000 ms (5 minutes)

bucketId = 300001 / 300000 = 1 âœ…
```

---

### Storage Calculation:

**Worst case: 1 second = 1 point**

```
Calculations:
24 hours Ã— 60 min Ã— 60 sec = 86,400 points/day

Point size:
- open: 4 bytes
- close: 4 bytes
â†’ 8 bytes/point

Day: 86,400 Ã— 8 = 691,200 bytes = 0.7 MB
Year: 0.7 MB Ã— 365 = 255 MB

Verdict: âœ… Acceptable!
```

**5-minute buckets:**
```
1440 min/day Ã· 5 = 288 buckets
86,400 points Ã· 288 = 300 points/bucket
```

---

### IndexedDB Durability:

```
Reduce durability:
âœ… Increase throughput
âœ… More requests handled
âœ… OK to lose 1% of data (not critical Ğ´Ğ»Ñ charts)
```

---

## 5. ğŸ“‰ Data Upsampling & Downsampling

### Downsampling (More â†’ Less) â­

**Scenario:**
```
Current: 5-minute timeframe
Change to: 1-hour timeframe
```

**Solution: Aggregate existing data**

```
5-minute buckets (0-60 min):
[Bucket 0] [Bucket 1] ... [Bucket 11]

Downsample to 1 hour:
â†’ Take open from Bucket 0 (first point)
â†’ Take close from Bucket 11 (last point)
â†’ Create 1 single 1-hour point

Result: âœ… No server request!
Process: Lossless
```

---

### Upsampling (Less â†’ More)

**Scenario:**
```
Current: 1-hour timeframe
Change to: 5-minute timeframe
```

**Problem:**
```
Can't create detailed data from aggregated
â†’ Need server request
```

**Temporary Solution: Placeholders**

```
While waiting for API:
1. Create empty 5-minute buckets
2. Fill each with duplicated 1-hour entry
3. Show placeholder chart (loading state)
4. Replace when real data arrives

Result: User sees something (not blank)
Process: Lossy (temporary)
```

---

## 6. ğŸ”Œ Data API

### Protocol Comparison:

#### A. WebSockets

**Pros:**
```
âœ… Real-time communication
âœ… Low latency
âœ… Binary data
âœ… Bidirectional
```

**Cons:**
```
âŒ High complexity (serialization, error handling, reconnection)
âŒ Stateful (hard to scale)
âŒ Hard to load balance
```

---

#### B. Server-Sent Events (SSE)

**Pros:**
```
âœ… HTTP/2 based
âœ… Stateless (auto reconnection)
âœ… Multiplexing (200 streams per TCP connection)
âœ… Easy to scale
```

**Cons:**
```
âŒ Slower than WebSockets
âŒ Text data only
âŒ Unidirectional (OK Ğ´Ğ»Ñ Ğ½Ğ°ÑˆĞµĞ³Ğ¾ use case)
```

---

#### C. HTTP Streaming

**Pros:**
```
âœ… Binary data
âœ… HTTP/2 benefits
```

**Cons:**
```
âŒ Slow (TCP handshake overhead)
âŒ No frame marking (can't mark data boundaries)
â†’ Not suitable Ğ´Ğ»Ñ financial data
```

---

#### D. WebTransport â­ FUTURE

**Pros:**
```
âœ… UDP-based (QUIC protocol)
âœ… Zero RTT (no 3-way handshake)
âœ… Faster than WebSockets
âœ… Binary data
âœ… Frame marking support
```

**Cons:**
```
âŒ Limited support (60% browsers)
âŒ Not all servers support
```

**Verdict:**
```
Modern apps â†’ WebTransport
Legacy support â†’ WebSockets Ğ¸Ğ»Ğ¸ SSE
```

---

### Binary Data & Protobuf

**Why Binary:**
```
Text data: Large size
Binary data: Compressed

Protobuf: 6-8Ã— compression
â†’ Reduces bandwidth
â†’ Improves latency
```

**Trade-off:**
```
Cost: Serialization/Deserialization overhead
Benefit: Massive data reduction
Verdict: âœ… Worth it Ğ´Ğ»Ñ large datasets
```

---

### Unified Interface:

```typescript
interface IDataAPI {
  getData(
    assetId: string,
    start: number,
    end: number,
    timeframe: Interval
  ): TData;
}

// Implementations:
class WebSocketAPI implements IDataAPI { }
class SSE_API implements IDataAPI { }
class WebTransportAPI implements IDataAPI { }
```

**Subscription Pattern:**
```
Subscribe Ğ´Ğ»Ñ specific data
â†’ Different transports (WebSockets, SSE, WebTransport)
â†’ Same interface
â†’ Easy to switch
```

---

## 7. ğŸ–¥ï¸ Multi-Window Support

### Concept:

```
Window 1 (Host)          Window 2 (Extension)
     â†“                         â†“
 [State Master]          [State Replica]
     â†“                         â†‘
     â””â”€â”€â”€â”€ Broadcast Channel â”€â”€â”˜
```

---

### Architecture:

**Window 1 (Host):**
```
âœ… Controls layout
âœ… Manages sync config
âœ… Writes state updates
âœ… Fetches data
```

**Window 2 (Extension):**
```
âœ… Reads state
âœ… Displays charts
âŒ NEVER writes state directly
â†’ Sends events to Host
```

---

### Communication:

**1. LocalStorage (Initialization)**

```typescript
localStorage:
{
  hostId: "window-abc123",
  extensionIds: ["window-xyz789", "window-def456"]
}

Window 2 checks:
if (localStorage.hostId) {
  // Connect to host
}
```

---

**2. Broadcast Channel (Real-time)**

```typescript
// Host â†’ Extension
channel.postMessage({
  event: "chart-update",
  payload: {
    chartId: "chart-1",
    assetId: "AAPL",
    data: { ... }
  }
});

// Extension â†’ Host (request)
channel.postMessage({
  event: "fetch-data",
  payload: {
    assetId: "TSLA",
    sourceId: "window-xyz789"
  }
});
```

---

### Benefits:

```
âœ… No race conditions (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Host Ğ¿Ğ¸ÑˆĞµÑ‚)
âœ… State synchronization (Host controls)
âœ… Same IndexedDB (shared storage)
âœ… Broadcast Channel (event-based communication)
```

---

## ğŸ“Š Component Data Flow

```
User Action (change interval)
    â†“
Dashboard Component
    â†“
Check IndexedDB
    â†“ Cache MISS
API Request (WebTransport/WebSockets)
    â†“
Store in IndexedDB (bucketed)
    â†“
Update ApplicationState
    â†“
Chart Element
    â†“
Transformer (TData â†’ ChartData)
    â†“
Render Chart
```

**Synchronization:**
```
Chart 1 changes interval â†’ All charts update
â†’ Dashboard Component broadcasts
â†’ All charts re-render
```

---

## ğŸ“ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ñ‹

### 1. **Sandwich Design (3 Layers)**
```
CSS Grid + Cell Grid + Charts
Event delegation (1 handler)
Memory efficient
```

### 2. **IndexedDB + Bucketing â­**
```
5-minute buckets â†’ 12 buckets Ğ´Ğ»Ñ 1 hour
O(12) Ğ²Ğ¼ĞµÑÑ‚Ğ¾ O(3600)
Multiple timeframes (5m, 1h, 1d)
Compound key: assetId-bucketId-timeframe
```

### 3. **Data Sampling**
```
Downsample: Aggregate buckets (lossless)
Upsample: Placeholders + API request (lossy)
```

### 4. **WebTransport > WebSockets**
```
Faster (Zero RTT)
UDP-based (QUIC)
Future standard
```

### 5. **Multi-Window = Host + Extensions**
```
Host controls state
Extensions read only
Broadcast Channel communication
```

### 6. **Binary Data + Protobuf**
```
6-8Ã— compression
Reduced bandwidth
Worth serialization cost
```

---

**Ğ’Ñ€ĞµĞ¼Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ:** ~60 Ğ¼Ğ¸Ğ½ÑƒÑ‚  
**Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ:** Senior/Staff Frontend Engineer  
**ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸:** Trading companies, Bloomberg, Interactive Brokers, TradingView

Ğ£Ğ´Ğ°Ñ‡Ğ¸ Ğ½Ğ° Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²ÑŒÑ! ğŸ“ˆğŸš€